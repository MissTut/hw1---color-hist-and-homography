# -*- coding: utf-8 -*-
"""hw1 - color hist and homography.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PcfemZ40RaOYa1JNxLMZKhvy67O8BIam
"""

# import the necessary libraries
import numpy as np
import pandas as pd
from skimage.color import hsv2rgb, rgb2hsv, rgb2gray
from sklearn.metrics import accuracy_score
from scipy.spatial.distance import pdist
from scipy.special import rel_entr
from skimage.io import imshow, imread 
from sklearn.cluster import KMeans
import matplotlib.pyplot as plt
from scipy.spatial import cKDTree
import cv2

# HSV Kmeans model with total number of entry K=[64, 128]
def getHSVColorTable(im_path, K):
  img = cv2.imread(im_path)     
  image = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)     
  image = image.reshape((image.shape[0] * image.shape[1], 3))     
  K = k     
  for k in K:         
    if k == 64:             
      color_table64 = KMeans(n_clusters = 3)             
      color_table64.fit(image)         
    else:              
      color_table128 = KMeans(n_clusters = k)             
      color_table128.fit(image)    
  return img, color_table64, color_table128

from numpy.lib.histograms import histogram
# For each image compute a color histogram
def getHSVHist(im, color_table, opt):
  color_table, color_table64, color_table128 = getHSVColorTable(im[0], [64, 128])
  ht, wid, _ = np.size(im)
  if opt == 'euc':
    dist = pdist(color_table, np.reshape(im, [ht*wid, 3]))
  elif opt == 'kld':
    dist = sum(rel_entr(color_table, np.reshape(im, [ht*wid, 3])))
  _, min_idx = min(dist)
  h64 = histogram(min_idx, range(1, 64))
  h128 = histogram(min_idx, range(1, 128))
  return h64, h128

# HSV histogram feature to represent images 
im = cv2.imread('/content/im1.jpg')
color_table, color_table64, color_table128 = getHSVColorTable(im[0], [64, 128])
hsv_hist64, hsv_hist64 = getHSVHist(im, color_table, opt = 'euc')
print("hsv_hist64 shape is: ", hsv_hist64.shape)

test_set = hsv_hist64[1: 10]
train_set = hsv_hist64[11: 40]
n_class = 15
n_img = 40

for K in range(1, n_class):
  offs = (K - 1) * n_img
  kmeans = KMeans(3).fit(train_set)
  pred = kmeans.fit_predict(test_set)
  
accuracy_score(test_set, pred)

# Computing SIFT
# Read the image
img1 = cv2.imread('/content/im1.jpg')
img2 = cv2.imread('/content/im2.jpg')

# Convert image to gray scale
gray_im1 = cv2.cvtColor(img1, cv2.COLOR_BGR2GRAY)
gray_im2 = cv2.cvtColor(img2, cv2.COLOR_BGR2GRAY)

# Create a SIFT feature extractor
sift = cv2.xfeatures2d.SIFT_create()

# Detect SIFT features
key1, desc1 = sift.detectAndCompute(img1, None)
kp1 = sift.detect(gray_im1, None)
key2, desc2 = sift.detectAndCompute(img2, None)
kp2 = sift.detect(gray_im2, None)

# Creating a feature matcher
feat_m = cv2.BFMatcher(cv2.NORM_L1, crossCheck = False)

# Match both image's descriptors
match_desc = feat_m.knnMatch(desc1, desc2, k=2)

# Finding the best 8 matches
# A good match has a distance of less than 0.80
best_8 = []
best8_noList = []
for (x, y) in match_desc:
  if x.distance < 0.80*y.distance:
    best_8.append([x])
    best8_noList.append(x)

draw_params = dict(matchColor = (0,255,0),
                   singlePointColor = (255,0,0),
                   flags = 0)
img3 = cv2.drawMatchesKnn(img1, key1, img2, key2, best_8[:8], None,**draw_params)
fig = plt.figure(figsize = (15, 10))
ax = fig.add_subplot(111)
ax.imshow(img3)
plt.show()

len(best8_noList)

# Draw keypoints
img_1 = cv2.drawKeypoints(gray_im1,key1,img1)
plt.imshow(img_1)

# Draw keypoints
img_2 = cv2.drawKeypoints(gray_im2,key2,img2)
plt.imshow(img_2)

# Homography
if len(best_8) > 10:
  src_pts = np.float32([key1[m.queryIdx].pt for m in best8_noList]).reshape(-1, 1, 2)
  dst_pts = np.float32([key2[m.trainIdx].pt for m in best8_noList]).reshape(-1, 1, 2)

A, status = cv2.findHomography(src_pts, dst_pts, cv2.RANSAC)
A

# SVD computation
U, s, V = np.linalg.svd(A)
print("U: ", U)
print("--------------------------------------------------------------------")
print("s: ", s)
print("--------------------------------------------------------------------")
print("V: ", V)

# Find the nullspace of the homography solution
F, mask = cv2.findFundamentalMat(src_pts, dst_pts, cv2.FM_LMEDS)
print("F: \n", F)
print("---------------------------------------------------------------")
print("Mask: \n", mask)

# Convert keypoint into numpy array
pts1 = np.asarray([key_point.pt for key_point in key1]).reshape(-1, 1)
pts2 = np.asarray([key_point.pt for key_point in key2]).reshape(-1, 1)
A = np.full_like(pts1, 1)
# Finding the number of SIFT points that are in agreement with the homography
kdtree = cKDTree(pts1)
dists, inds = kdtree.query(A, distance_upper_bound=1e-5)
result = (dists == 0).sum()
result